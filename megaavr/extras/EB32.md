# AVR32EB32/AVR16EB32

## Pin Mapping / Pinout
`![EB32 Pin Mapping](AVRxxEB32.svg "Arduino Pin Mapping for AVR EB32")`
**Image not available - absent help we do not foresee being able to provide any sort of pinout diagram for this or future parts**


## Features and Peripherals
| Feature                        | AVR16EB32       | AVR32EB32       |
|--------------------------------|-----------------|-----------------|
| Flash Memory                   | 16384           | 32768           |
| Flash Memory (with Optiboot)   | 15872           | 32256           |
| SRAM                           | 2048            | 4096            |
| EEPROM                         | 512             | 512             |
| User Row                       | 64              | 64              |
| Boot Row (w/e that is)         | 64              | 64              |
| Max. Frequency (rated, MHz)    | 20              | 20              |
| Clock Sources                  | INT, EXT        | INT, EXT        |
| Packages Available             | TQFP, VQFN      | TQFP, VQFN      |
| Total pins on package          | 32              | 32              |
| I/O Pins (not reset/UPDI)      | 26              | 26              |
| Fully async pins               | 28              | 28              |
| UPDI as I/O Pin                | Yes             | Yes             |
| PWM capable I/O pins           | 17              | 17              |
| Max simultaneous PWM outputs   | 8               | 8               |
| 16-bit Type A Timers - pins ea | None            | None            |
| 16-bit Type B Timers, (pins)   | 2: 2/2          | 2: 2/2          |
| 12-bit Type D pins             | None            | None            |
| 16-bit Type E pins w/WEX       | 1: 4/2/4/3/3/3  | 1: 4/2/4/3/3/3  |
|  8-bit PWM via 24bit TCF       | 1: 2/2/2        | 1: 2/2/2        |
| USART (pin mappings)           | 1: 6            | 1: 6            |
| SPI (pin mappings)             | 1: 5            | 1: 5            |
| TWI/I2C (pin mappings)         | 1: 3            | 1: 3            |
| 12-bit ADC input pins          | 24              | 24              |
| Of those, neg. diff. inputs    | all             | all             |
| 10-bit DAC                     | None            | None            |
| Analog Comparator (AC)         | 2               | 2               |
| Zero-Cross Detectors (ZCD)     | 0               | 0               |
| Custom Logic Blocks (LUTs)     | 4               | 4               |
| Event System channels (out pins)| 6: 3           | 6: 3            |
| On-chip opamps (OPAMP)         | -               | -               |
| MVIO, pins                     | No              | No              |
| Flash Endurance                | 1k              | 1k              |
| LED_BUILTIN (and optiboot led) | PIN_PA7         | PIN_PA7         |

`*` VQFN is 5mm x 5mm 0.5mm pitch

## AVR EB32 - A new generation of... timers
The EB-series is looking like a proofing ground for a pair of new timers and the crazy clock controller they bring along, plus, finally, a migration path for users of the venerable ATtiny861 for BLDC motor control applications. These new timers have some really impressive features - though sadly most get buried by the arduino API. Some of the features may get a stock wrapper library. On the higher pincounts, the lack of a second USART looks rather backward.

The CLKCTRL has a *very* fancy PLL by AVR standards - what its maximum speed will be is not now known to be 80 MHz rated, but this is a hell of a step up from 2x/3x/(secret)4x of the Dx - 1/2/4/6 input prescale, 8 or 16x multiplication then optionally a prescale by 2. And it can be used as the system clock. There's also something called "Prescaler B" which is /1 or /4, and prescales the CPU clock.

### Fully async pins
All pins on the EBs are "fully async" and can respond to events shorter than 1 clock cycle, and can wake the chip on RISING or FALLING edges, not just LOW_LEVEL and CHANGE, whether or not the I/O clock is running. There are good and bad sides to this. The good are obvious, the bad is reduced noise rejection: Triggering from signals less than 1 clock long also means triggering from noise less than 1 clock long.

### This has the "Good" ADC
First introduced on the tinyAVR 2-series, this has the new 12 bit differential ADC WITH a Programmable Gain Amplifier. This is a real differential ADC that you can do all the usual tricks with, in addition to the up to 16x selectable gain. (The AVR Dx ADC is considerably worse than it sounds, comparatively, if you care about differential measurements. A differential reading on the Dx does not seem to be able to achieve anything that could not be achieved by kicking off a matched pair of ADCs simultaneously and automatically subtracted the results - particularly, you can't have either of the voltages higher than the reference voltage, so you can't do the classic trick where you look at a high-side sense resistor (at around Vdd) and take a differential reading across it at maximum gain with the lowest reference voltage.


### USART mux options
There is ONLY ONE USART on these things but damn does it have a lot of mux options...

| USART0  | swap |  TX |  RX | XDIR | XCK |
|---------|------|-----|-----|------|-----|
| DEFAULT | 0    | PA0 | PA1 |  PA2 | PA3 |
| ALT1    | 1    | PA4 | PA5 |  PA6 | PA7 |
| ALT2    | 2    | PA2 | PA3 |   -  |  -  |
| ALT3    | 3    | PD4 | PD5 |  PD6 | PD7 |
| ALT4    | 4    | PC1 | PC2 |  PC3 |  -  |
| ALT6    | 6    | PF7 | PF6 |   -  |  -  |
| none    | 7    |  -  |  -  |   -  |  -  |

Option ALT5 does not exist and to my knowledge never has.

Option ALT6 does indeed require use of the RESET pin as RX (a minor inconvenience) *and* the UPDI pin as TX (a much larger one), thus those pins must be changed to be GPI and GPIO respectively. Note that unlike all other modern non-tinyAVR parts, the RX pin comes before the TX pin - this was forced upon them by the fact that RESET is PF6, and RESET has no output drivers, because it's the HV programming pin that gets the HV UPDI pulse.. They probably should have put the UPDI pin on PF6 and Reset on PF7, for a variety of reasons, but it's not worth further thought

### SPI0 mux options
Lots of mux options here! These get the extras picked up for the DD's low pincount, plus the originals they were there to replace, since the EB's aren't missing a pin like the DD or 3 like the DU.

| SPI0    | swap | MOSI | MISO | SCK |  SS |
|---------|------|------|------|-----|-----|
| DEFAULT | 0    |  PA4 |  PA5 | PA6 | PA7 |
| ALT3    | 3    |  PA0 |  PA1 | PC0 | PC1 |
| ALT4    | 4    |  PD4 |  PD5 | PD6 | PD7 |
| ALT5    | 5    |  PC0 |  PC1 | PC2 | PC3 |
| ALT6    | 6    |  PC1 |  PC2 | PC3 | PF7 |
| none    | 7    |   -  |   -  |  -  |  -  |

Using ALT6 in slave mode requires PF7 to be set as GPIO, with attendant complications.

### TWI0 mux options
This is a standard TWI.

| Mapping | swap | Master or Slave | Dual Mode Slave |
|---------|------|-----------------|-----------------|
| DEFAULT | 0    | SDA/PA2 SCL/PA3 | SDA/PC2 SCL/PC3 |
|~ALT1~   | ~1~    | ~SDA/PA2 SCL/PA3~ | ~not avail.~|
| ALT2    | 2    | SDA/PC2 SCL/PC3 | ~Not avail.~    |
| ALT3    | 3    | SDA/PA0 SCL/PA1 | SDA/PC2 SCL/PC3 |

ALT1 and ALT2 both normally use PC6 and PC7 - except that those pins only appear on 48-pin parts - for the dual mode slave pins.

ALT1 is not a valid option because it is strictly worse than default - Default with dual mode turned off (the default) is identical to ALT1 with dual mode off, but with ALT1 pinout, dual mode won't have a prayer of working, while on default it will, on PC2, PC3


### PWM Pins
PWM IS NOT YET IMPLEMENTED ON ON TCE OR TCF.

Okay, this gets mighty complicated. Normally we get 6 pins in split mode from the first TCA, allocated 1 option per port, 1 from each TCB not used for millis, and 2 from the TCD, if present.
We only have one type of timer we know here: the TCBs, of which we have a mated pair. The TCA's role as a primary PWM timer is taken instead by a new type of timer, the Type E timer, a 4-channel, *non-splitable* 16-bit timer, clearly derived from TCA, This is supplemented by a second novel timer, this one derived from the TCB, the 24-bit TCF. Before you start asking about the 24-bits - It's PWM mode is like TCB - you only get two output channels, and they're 8-bit.


Both of these timers are *special* having features inextricably linked to the new PLL.

#### TCE0 Mux Options
Our primary timer for PWM is the TCE. We have the following mux options for it. As the largest chip of he set, I've attempted to extrapolate what the master chart in the AVR war room must have listed for the TCE portmux.

This timer gives us only FOUR outputs, even though it has 8 pins - we can get inverted outputs out of the other half of the pins with independent dead time generation if we happen to vbe driving a brushless DC motor or multiphase DC-DC converter


| Port    | Number | *WO0*  | *WO1*  | *WO2*  | *WO3*  | WO4    | WO5    | WO6   | WO7   |
|---------|--------|--------|--------|--------|--------|--------|--------|-------|-------|
| PORTA   |   0    | PA0    | PA1    | PA2    | PA3    | PA4    | PA5    | PA6   | PA7   |
| ~PORTB~ |  ~1~   | ~PB0~  | ~PB1~  | ~PB2~  | ~PB3~  | ~PB4~  | ~PB5~  | ~PB6~ | ~PB7~ |  Theorized, should a >32 pin part with a TCE come out.
| PORTC   |   2    | PC0    | PC1    | PC2    | PC3    | ~PC4~  | ~PC5~  | ~PC6~ | ~PC7~ |  Theorized, should a >32 pin part with a TCE come out.
| PORTD   |   3    | PD0    | PD1    | PD2    | PD3    | PD4    | PD5    | PD6   | PD7   |
| ~PORTE~ |  ~4~   | ~PE0~  | ~PE1~  | ~PE2~  | ~PE3~  | ~PE4~  | ~PE5~  | ~PE6~ | ~PE7~ |  Theorized, should a >32 pin part with a TCE come out.
| PORTF   |   5    | PF0    | PF1    | PF2    | PF3    | PF4    | PF5    | -     | -     |
| ~PORTG~ |  ~6~   | ~PG0~  | ~PG1~  | ~PG2~  | ~PG3~  | ~PG4~  | ~PG5~  | ~PG6~ | ~PG7~ |  Theorized, should a >32 pin part with a TCE come out.
| ~???~   |  ~7~   | Who    | knows  | what   | the    | plan   | is     | for   | this  |
| PORTC2  |   8    | PA0    | PA1    | PC0    | PC1    | PC2    | PC3    | -     | -     |  Notice how here we start on 6-pin whackjob pinouts. It is possible that with >32 pins, PC4 and PC5 would finish out this one
| PORTA2  |   9    | PA2    | PA3    | PA4    | PA5    | PA6    | PA7    | -     | -     |

TCE is planned to get PORTMUX awareness, default port will be PORTC, as that means all parts will get 4 pwm pins in a consistent spot. On the 32-pin, PORTF is likely preferable - and with all 6 port options having all of their lower half intact, the 32pin parts are unconstrained here.

Note that we now have a 4-bit mux option register, and there are two whacko pinouts. Plus, it's not clear what pins we can output PWM on... Do we get the even ones, or do we get 0, 1, 2, 3? Do we have a choice? I think we get 0,1,2,3 - it obviously blows the others out of the water for us

TCE may be offered as a millis timekeeping source under the same terms as TCA is.

##### TCE + WeX advanced features
Infamous supervillian WeX Luther is back! (*Superman's enemy? That's "Lex Luther"* "This one definitely said his name was WeX... But read this chapter of the datasheet about it. I think you'll have to agree that villianry was involved...." *Wow, long chapt-* "- and you'll need the TCE chapter, can't understand one without the other" *Ugh, what are these, the two longest chapters?* "Yes. Oh, and here, CLKCTRL - that's important here too." *Jeez* "The TCA was already one of the longest chapters in the datasheet (largely because of the split/single mode thing, which we lost)" *Boooooo!* "and TCE filled that space and more, then WeX himself went on for as long again (much of it somewhat incoherrent, but it was gonna change the world)." *supervillians changing the world... couldn't go wrong* "I think it was 'change' - something like that" *What are all these cool features?* "Uhm, there's HiRes, and uh, well if you were driving brushless DC motors or synchronous DC-DC converters, there's programmable deadtime insertion. And some of the TCD fault detection junk, which is also for BLDC and switch mode applications" And

###### TCE EVENT generators have selectable output: pulse or waveform!
This makes it *really easy* to pipe an inconvenient or nonexistent pin's WO channel to an extant one. *Cool, I can reroute that hard-to-get-at uh.... damn. They give us it the workaround only after removing the problem? No fair!*

Example planned.

###### TCE HiRes (as in High-Resolution, not the third person present tense of 'to hire')
When the CPU is clocked from the PLL through the PRESCB /4 prescaler, that means a a 4x F_CPU clock is available. If enabled, the HIRES module will take control of the 2 or 3 LSB of the compare match, and those bits will no longer be updated in TCE0.CNT. These will be counted off and compared in the HIRES module, using the rising edges of the CLKx4 for 4x resolution, or using both edges for 8x resolution.

This means that while keeping the frequency constant, one can increase the resolution by 4x or 8x, or the resolution can be kept constant while increasing the frequency by 4x or 8x

This helps to address the fact that 16 bit PWM with a 20 MHz clock is only 305 Hz, which is a littlle slow for most PWM applications (1 kHz is a what we target for 8-bit PWM). With HiRes, it can be raised to 2.44 kHz while retaining full resolution.

An example demonstrating this is planned.

Using this requires the user takeOverTCE0()

###### WeX dead-time insertion
Yes, it's got a very fancy dead-time inserter, lets you specify delays for bottom, top and both, so you can get 4 PWM outputs each split into lowside and inverted high side outputs that don't overlap and have the specified amount of dead-time,

No, I have no plans to do an example. It's mostly of interest for motor control commutation applications.

###### WeX Pattern Generation
*Could you figure out what the f___ he was talking about here?* "No, that was one of the incoherrent parts" *seriously...* "Sounds like it's a special feature for motors" *That's what the last one was!* "The next one, too"

\o/

###### WeX Fault Detection and Generation
*It looks kinda like TCD's?* "Naw, waay fancier" *Useful?* "Maybe for some motor control applications" *Do we get a version of that cool progev thing TCD had?* "Nope. Not useful for driving motors." *dang, too bad, yeah. If I could gave piped the output of that selectable duration digital filter to an event channel of my choice, imagine the possibilities....*


#### TCB mux options
There are two type B timers. They now have a CNT_SIZE option to lose bits from the top of the MSB of the period (ie, so you can trigger OVF interrupt sooner in things like timeout check mode?) TCB1 is default millis timer for now.

| TCBn | Default | Alt1 | Notes
|------|---------|------|----------
| TCB0 | **PA2** |  PF4 |
| TCB1 | **PA3** |  PF5 | Default millis timer

Yeah, the pin options are not great - they never are for the TCBs, of course - they're always on PA2/3 PF4/5, then C0-1, B4-5 (well, C0 alt B4 for TCB2, and B5 alt C1 for TCB3),

#### TCF and Mux options
The TCF is a 24-bit asynchronous timer (can be clocked from the PLL, and the clock system we get is as baller as you can hope for with a 16/20 fuse-selected base oscillator and no external crystal). The PLL rated for running at up to **80 MHz** (and we know how conservative Microchip's specs are).

Now, knowing our powers of (2<sup>8</sup>), we know 2^24 is 16.7 million. That means clocked with no prescaler from the CPU, it would take just over a second, or about 800ms to overflow. The PLL only lowers that by a factor of 4. Basic math tells you that those extra bits would be of dubious utility for many even most applications clocked at the sedate 20 MHz maximum clock of the CPU. The TCF can clock from the

The TCF's featureset seems barebones compared the the monstrosity that is TCE, See [[Ref_TCF.md]]

| Mux option | WO0 | WO1 |
|------------|-----|-----|
| Default    | PA0 | PA1 |
| ALT1       | PA6 | PA7 |
| ALT2       | **PF4** | **PF5** |

TCF is planned to get portmux awareness for PWM mode, into which it will be initialized; however, note that we do not have a facility to handle pins with a TCB and a TCF on them - we can be aware that it's an option for TCF. or that it has TCBn on it, but not both. Luckily, DxCore does not support switching TCB portmux options at runtime, requiring changes to the variant file (you'd need to adjust the bottommost table accordingly, in addition to adjusting TCBn_PINS and TCF0_PINS).

TCF may become usable for millis timekeeping (it will have caveats; the main prize is that the millis interrupt would be reduced to once per several seconds, rather than once per millisecond

##### TCF EVENT generators have selectable output: pulse or waveform
This makes it *really easy* to pipe an inconvenient or nonexistent pin's WO channel to an extant one. *Okay, this is useful on some of the low-pincount parts...* "Yeah, definitely" *Saaaay....*

*What if I set the **event** output to level, set CCL_LUTn as user. Set it waveform outputting. Then on LUTn of the CCL, I just mask in1, 2, in0 is the event channel, truth 0x02,. Then next CCL LUT I configure the same way, except instead of an evetn channel, I get the WO direct from the CCL mux. I output both to a pin, and look at them side by side on the scope? what will I see? What about if I switched to pulse on the event? Would that happen after, at the same instant as, or right before the WO changed?*

"Well, I think.... that you're going to be spending some time working with some EB's soon to figure that out"

Example planned.
### LED_BUILTIN
To match other parts, `PIN_PA7` shall be the pin that the core "expects" to be connected to an LED. If you want to have a different pin be recognized by the application (this does not change the bootloader - you would still need to do a custom build of that too), this can be overridden if a custom board definition is created by passing `-DLED_BUILTIN=(some other pin)` as part of build_extra_flags, building via the CLI, or by equivalent means provided by other third party development environments.

## Official Documentation
When all else fails, read the real documentation. They keep moving the .pdf files around, so now I just link to the prduct page, from whence the datasheet, errata, and "technical briefs" are linked.

**Datasheets and errata change. You can sign up to get emails about such changes through the Microchip PCN system; if you don't, be sure to always use the latest version of the datasheet and especially the errata**

* [AVR32EB32](https://www.microchip.com/en-us/product/AVR32EB32#Documentation)
* [AVR16EB32](https://www.microchip.com/en-us/product/AVR16EB32#Documentation)

(Note: The datasheet is believed to be identical, the errata is currently identical, but that could change). See also the [Errata Reference](./Ref_Errata.md).

At a minimum, everyone using a modern AVR beyond the Arduino API should plan on having a PDF viewer open with the datasheet, and a text editor with a good search function and the ioavr__eb__.h  file open so that when you're trying to use a constant, but the compiler says it isn't declared/defined, you can search the io header for a key phrase in the constant and figure out how it was spelled/formatted or copy/paste it to your sketch. (see [the IO headers](./ioheaders) for more information and links to them. I also keep the AVR instruction set manual open in the PDF viewer if I'm doing anything deep. For most modern parts, unfortunately, you're also definitely going to need the the silicon errata and datasheet clarification document in addition to the latest version of the datasheet - that is the document that lists silicon bugs and which die revs this and parts they're present on; if they list something as an erratum, that means that, in theory, maybe, some day, silicon without any of the errata will be available, but I'm not confident it will happen before the sun runs out of fuel and puffs up into a red giant, engulfing the inner planet. That last part would cause problems for terrestrial semiconductor manufacturers as well as their customers. (*Yeah, with all that radiation, process yields would tank...* "And staffing problems too, what with the extermination life on the planet" *That too. It would really shake things up, for sure*)... Anyway, as of early 2025, the DB and the EA have received die-revs that make a difference (no other part hasBoth the DB and EA have now (the former due to it being the flagship and having a lot of very visible bugs. The latter because they did something horribly wrong with the self-programming system there. Datasheet clarifications are a bigger deal than an erratum, usually. An erratum says "Okay, this doesn't work, but it will some day, maybe" while a datasheet clarification says "This would be an errata, but we're not even going to pretend that we'll fix it some day". But watch out - datasheet clarifications vanish from the list once the datasheet has been updated!

The "Technical Briefs" are [somewhat inconsistent](https://github.com/SpenceKonde/AVR-Guidance/blob/master/TechnicalBriefs.md) in their value, but some are quite good.
