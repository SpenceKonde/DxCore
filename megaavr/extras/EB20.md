# AVR32EB20/AVR16EB20/AVR8EB20
**WARNING** This document is based largely on speculation and the very limited public information about these parts.


## Pin Mapping / Pinout
`![EB20 Pin Mapping](AVRxxEB20.svg "Arduino Pin Mapping for AVR EB20")`
**Image not available - absent help we do not forsee being able to provide any sort of pinout diagram for this or future parts**

## Features and Peripherals
| Feature                        | AVR16EB20       | AVR32EB20       |
|--------------------------------|-----------------|-----------------|
| Flash Memory                   | 16384           | 32768           |
| Flash Memory (with Optiboot)   | 15872           | 32256           |
| SRAM                           | 2048            | 4096            |
| EEPROM                         | 512             | 512             |
| User Row                       | 64              | 64              |
| Boot Row (w/e that is)         | 64              | 64              |
| Max. Frequency (rated, MHz)    | 20              | 20              |
| Clock Sources                  | INT, EXT        | INT, EXT        |
| Packages Available             | SOIC, VQFN      | SOIC, VQFN      |
| Total pins on package          | 20              | 20              |
| I/O Pins (not reset/UPDI)      | 16              | 16              |
| Fully async pins               | 18              | 18              |
| UPDI as I/O Pin                | Yes             | Yes             |
| PWM capable I/O pins           | 11              | 11              |
| Max simultaneous PWM outputs   | 6               | 6               |
| 16-bit Type A Timers - pins ea | None            | None            |
| 16-bit Type B Timers, (pins)   | 2: 2            | 2: 2            |
| 12-bit Type D pins             | None            | None            |
| 16-bit Type E pins w/WEX       | 1: 4/2/2/1/3    | 1: 4/2/2/1/3    |
| 8-bit PWM via 24bit TCF        | 1: 2/2          | 1: 2/2          |
| USART (pin mappings)           | 1: 6            | 1: 6            |
| SPI (pin mappings)             | 1: 5            | 1: 5            |
| TWI/I2C (pin mappings)         | 1: 2            | 1: 2            |
| 12-bit ADC input pins          | 8               | 8               |
| Of those, neg. diff. inputs    | all             | all             |
| 10-bit DAC                     | None            | None            |
| Analog Comparator (AC)         | 2               | 2               |
| Zero-Cross Detectors (ZCD)     | 0               | 0               |
| Custom Logic Blocks (LUTs)     | 4               | 4               |
| Event System channels (out pins)| 6: 3           | 6: 3            |
| On-chip opamps (OPAMP)         | -               | -               |
| MVIO, pins                     | No              | No              |
| Flash Endurance                | 1k              | 1k              |
| LED_BUILTIN (and optiboot led) | PIN_PA7         | PIN_PA7  |

## AVR EB20 - A new generation of... timers
The EB-series is looking like a proofing ground for a pair of new timers and the crazy clock controller they bring along, plus, finally, a migration path for users of the venerable ATtiny861 for BLDC motor control applications. These new timers have some really impressive features - though sadly most get buried by the arduino API. Some of the features may get a stock wrapper library. The 20-pin parts are still cramped for pins, but it's a lot less acute than it is for the 14-pin ones.

The CLKCTRL has a *very* fancy PLL by AVR standards - what its maximum speed will be is not now known to be 80 MHz rated, but this is a hell of a step up from 2x/3x/(secret)4x of the Dx - 1/2/4/6 input prescale, 8 or 16x multiplication then optionally a prescale by 2. And it can be used as the system clock. There's also something called "Prescaler B" which is /1 or /4, and prescales the CPU clock.

Breaking News - The 8k parts have withdrawn participation from EA and EB series. As the 8k EAs failed to show, it became one of the mysteries. 8k parts gone from a family where they don't belong? That makes total business sense, the EA never should have had an 8k version announced. But it did seem to all fit together into a coherent picture on the EB-series to have those three sizes. It was almost a tiny3, except with the pinmapping of non-tiny. On the plus side, the Dx/Ex/m0 mappings are very reasonable, and make a lot of shortcuts possible. On the other hand, strictly speaking, the tiny2's pinouts do a much better job of exposing peripheral functions. I have designs that use a 424 - the 424 is just a material vessal for the 4 CCLs and the central TCA that controls them (it uses 424. Every pin is used, 4 analog inputs, 4 CCL outputs, 1 input, and a timer to count pulses). We've reached out to the representatives of the 8k parts for comment, but have received no response.

### Fully async pins
All pins on the EBs are "fully async" and can respond to events shorter than 1 clock cycle, and can wake the chip on RISING or FALLING edges, not just LOW_LEVEL and CHANGE, whether or not the I/O clock is running. There are good and bad sides to this. The good are obvious, the bad is reduced noise rejection if you're able to respond to such brief signals.

### USART mux options
There is ONLY ONE USART on these damned things!

| USART0: | swap |  TX |  RX | XDIR | XCK |
|---------|------|-----|-----|------|-----|
| DEFAULT | 0    | PA0 | PA1 |   -  |  -  |
| ALT1    | 1    | PA4 | PA5 |  PA6 | PA7 |
| ALT2    | 2    | PA2 | PA3 |   -  |  -  |
| ALT3    | 3    | PD4 | PD5 |  PD6 | PD7 |
| ALT4    | 4    | PC1 | PC2 |  PC3 |  -  |
| ALT5    | 5    | PF7 | PF6 |   -  |  -  |

### SPI0 mux options
SPI0 has FOUR mux options at just 14 pins!

| SPI0    | swap | MOSI | MISO | SCK |  SS |
|---------|------|------|------|-----|-----|
| DEFAULT | 0    |  PA4 |  PA5 | PA6 | PA7 |
| ALT4    | 3    |  PA0 |  PA1 | PC0 | PC1 |
| ALT4    | 4    |  PD4 |  PD5 | PD6 | PD7 |
| ALT5    | 5    |  PC0 |  PC1 | PC2 | PC3 |
| ALT6    | 6    |  PC1 |  PC2 | PC3 | PF7 |


### TWI0 mux options
Note that this means that you want Wire.swap(2, or 3, but not 0 or 1). While swap level 0 is "implemented" in hardware it is not useful - you can do everything you could with swap 0 using swap 2 or swap3 3 and then some - and with binary size smaller than or equal to what can be achieved with swap 0. None of the pins used by swap 1 exist at all.

| Mapping | swap | Master or Slave | Dual Mode Slave |
|---------|------|-----------------|-----------------|
| DEFAULT | 0    | SDA/PA2 SCL/PA3 | SDA/PC2 SCL/PC3 |
| ~ALT1~  | ~1~  | ~SDA/PA2 SCL/PA3~ | ~Not avail.~  |
| ALT2    | 2    | SDA/PC2 SCL/PC3 | Not avail.      |
| ALT3    | 3    | SDA/PA0 SCL/PA1 | SDA/PC2 SCL/PC3 |
### PWM Pins
We know very little about these, but a surprising amount can be inferred.

#### TCB mux options
Did they take away the second alt mapping that was on the DU's list?

| TCBn | Default | Alt1 |
|------|---------|------|
| TCB0 | **PA2** |   -  |
| TCB1 | **PA3** |   -  |

We may swap the default millis timekeeping onto TCB0 for the EB, because that way the 8-bit PWM output is on a pin that TCE can't provide independent PWM to, but an inverted deadtime inserted output, which is... not very useful unless you're driving BLDC motors or making your own buck or boost converter, and certainly not amenable to analogWrite().

#### TCE+WEX
The headers reveal a 4-channel, 16-bit timer with enough extra features to sink a battleship. However, split mode is not one of them: Half of the outputs can only be inverted channels. It can do some insane stuff though; it looks like there's a mode to denominate the compare values in quarters or eighths of a tick ("HIRES", pronounced hi-res, not hires)... and of course, there's WEX, which is too different from what we know to work backwards from the header to the behavior.

| Mux option | WO0 |  WO1  | WO2 |  WO3  | WO4 |  WO5  | WO6 |  WO7  | Numeric value |
|------------|-----|-------|-----|-------|-----|-------|-----|-------|---------------|
| TCE0_PORTA | PA0 | ~PA1~ | PA2 | ~PA3~ | PA4 | ~PA5~ | PA6 | ~PA7~ | 0             |
| TCE0_PORTC | PC0 | ~PC1~ | PC2 | ~PC3~ |  -  |   -   |  -  |   -   | 2             |
| TCE0_PORTD |  -  |   -   |  -  |   -   | PD4 | ~PD5~ | PD6 | ~PD7~ | 3             |
| TCE0_PORTF | PF0 | ~PF1~ |  -  |   -   |  -  |   -   |  -  |   -   | 5             |
| TCE0_PORTC2| PA0 | ~PA1~ | PC0 | ~PC1~ | PC2 | ~PC3~ |  -  |   -   | 8             |
| TCE0_PORTA2| PA2 | ~PA3~ | PA4 | ~PA5~ | PA6 | ~PA7~ |  -  |   -   | 9             |

TCE is planned to get PORTMUX awareness, default port TBD.

How to implement it will be rather tricky, though...... Note that we now have a 4-bit mux option register, and there are two whacko pinouts. I guess if the pin is even, and PORTMUX is equal tp the port, that's a for sure - but then there's PORTC2 and PORTA2. (and we don't get to use the table, because an array can only hold one value per index. We already have a mondo problemo with TCF and TCB0/1).

#### TCF
TCF is a 24-bit asynchronous timer (can be clocked from the PLL, and the clock system we get is as baller as you can hope for with 16/20 fuse-selected base oscillator and no external crystal), running at up to **80 MHz**. **HOWEVER** it's full glory is only applicable to pulses-at-a-frequency, frequency generation, and fixed duty cycle output (no I don't know what it's fixed at. Update: WTF, 50%. Isn't that called frequency generation?). For proper PWM, it has to pull the same trick that TCB does, and it's 24-bit CMP register turns into a period register and two compare registers. But, you do get two PWM channels and an independent prescaler, at least.

| Mux option | WO0 | WO1 |
|------------|-----|-----|
| Default    | PA0 | PA1 |
| ALT1       | PA6 | PA7 |
| ~ALT2~     |  -  |  -  |

TCF is planned to get portmux awareness.

### LED_BUILTIN
Thank god - we have a PA7 here!

To match other parts, `PIN_PA7` shall be the pin that the core "expects" to be connected to an LED. If you want to have a different pin be recognized by the application (this does not change the bootloader - you would still need to do a custom build of that too), this can be overridden if a custom board definition is created by passing `-DLED_BUILTIN=(some other pin)` as part of build_extra_flags, building via the CLI, or by equivalent means provided by other third party development environments.

## Official Documentation
When all else fails, read the real documentation. They keep moving the .pdf files around, so now I just link to the prduct page, from whence the datasheet, errata, and "technical briefs".

**Datasheets and errata change. You can sign up to get emails about such changes through the Microchip PCN system; if you don't, be sure to always use the latest version of the datasheet and especially the errata**

* AVR32EB20 product page not available
* AVR16EB20 product page not available
* AVR8EB20 product page not available

At a minimum, everyone using a modern AVR should plan on having a PDF viewer open with the datasheet, and a text editor with a good search function and the ioavr______.h file open so that when you're trying to use a constant, but the compiler says it isn't declared/defined, you can search the io header for a key phrase in the constant and figure out how it was spelled/formatted or copy/paste it to your sketch. (see [the IO headers](./ioheaders) for more information and links to them. I also keep the AVR instruction set manual open in the PDF viewer as well as the silicon errata and datasheet clarification. Datasheet clarifications are a bigger deal than an erratum, usually. An erratum says "Okay, this doesn't work, but it will some day, maybe" while a datasheet clarification says "This would be an errata, but we're not even going to pretend that we'll fix it some day". But watch out - datasheet clarifications vanish from the list once the datasheet has been updated!

The "Technical Briefs" are [somewheat inconsistent](https://github.com/SpenceKonde/AVR-Guidance/blob/master/TechnicalBriefs.md) in their value, but some are quite good.
