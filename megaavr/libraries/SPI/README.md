# SPI for DxCore
The SPI library implements all of the standard functionality described in the [Arduino SPI library reference](https://www.arduino.cc/en/reference/SPI) applies here. Also, like all of the "big three" third-party cores for post-2016 AVR devices, this version of SPI.h supports the `swap()` and `pins()` methods to make use of the PORTMUX feature of the chips. However, there is an additional complication described below; this has finally been addressed in an (IMO) satisfactory way in 1.3.0.

## Pins
| Pin Mapping   | Pins    | Parts | Swap-level name   |   Synonym  | Value |
|---------------|---------|-------|-------------------|------------|-------|
| SPI0 DEFAULT  | PA4-PA7 | All   | SPI0_SWAP_DEFAULT | SPI0_SWAP0 | 0x00  |
| SPI0 ALT1     | PE0-PE3 | 48/64 | SPI0_SWAP_ALT1    | SPI0_SWAP1 | 0x01  |
| SPI0 ALT2     | PG4-PG7 | 64    | SPI0_SWAP_ALT2    | SPI0_SWAP2 | 0x02  |
| SPI1 DEFAULT  | PC0-PA3 | All   | SPI1_SWAP_DEFAULT | SPI1_SWAP0 | 0x10  |
| SPI1 ALT1     | PC4-PE7 | 48/64 | SPI1_SWAP_ALT1    | SPI1_SWAP1 | 0x14  |
| SPI1 ALT2     | PB4-PB7 | 64    | SPI1_SWAP_ALT2    | SPI1_SWAP2 | 0x18  |
The "Swap level" name is the argument passed to SPI.swap() to change the pin selection. See below for more information.


## Two SPI ports
The AVR DA/DB-series parts have two hardware SPI ports. On parts with more pins, they can be pin-swapped to different sets of pins (up to three sets of pins per SPI peripheral). The AVR DD-series has only a single SPI port - but it has a far more pin options than the DA/DB-series parts do. Originally, it was expected that two libraries could be created like is done for the few classic AVRs with multiple SPI ports (eg, ATmega328PB) and the many 32-bit architectures with multiple SPI ports; however, it was discovered in 1.2.0 (which attempted to implement this) that the existing libraries with which we desire compatibility (an SPI library that you need to modify everything you use with it is hardly satisfactory) were more challenging to work with than expected. In order to work with existing libraries, we need only guarantee that our instances of SPI_class have names matching the convention; that sounds like a low bar - and indeed, it is: the only way it could be a problem is if one of those key names happened to already be used for something!

### The problem
As noted above the `SPI_class` object for the second serial port would be named `SPI`. You may recall that Microchip names their peripherals (as defined in the io header files included by all sketches) as a small number of capital letters, followed by an integer, starting with 0. The first SPI peripheral, and the struct with references to all of it's registers, is named `SPI0`, the second is named `SPI1`.  It was discovered that in the field, the standard library solution is that if a board claims it has 2 SPI interfaces, SPI-using libraries will expect the second one to be an instance of SPI_class named SPI1, and if this was not the case, that would generate a compile error. Well - what do we do? It, of course, is possible to override the io headers - I considered this, but I think it sets a poor precedent to override "real" Microchip-declared peripheral names for the sake of making Arduino-land stuff work better. There was just no graceful way to have multiple SPI libraries

### The solution
However, on reflection - I realized that... does it really even make sense to have two instances of SPI_class?
1. It is rare to need two physical SPI ports - SPI is a bus, and many parts can share the same MISO, MOSI and SCK pins.
1. The standard SPI library API does not support slave mode, so the plausible case of a part being both a master to sensors or other simple devices, while something more computing-heavy like a Raspberry Pi controls it over SPI is not an issue. Because SPI.h has nothing to do with SPI slave mode, and another library must be used for that, all that we require of SPI.h to be no worse than the stock SPI library is that it not interfere with whatever SPI port it isn't using in master mode.
1. The most compelling reason to make use of the second SPI port and why it the original attempt at a second SPI library was such a high priority was due to the highly constrained pin options on the 28-pin and 32-pin parts - only one set of pins is available.  second SPI port is probably the fact that on 28/32-pin parts, the only available pins for SPI0 are PA4-PA7. Even without their being the only SPI pins accessible to a library limited to SPI0, those are the most powerful pins, with many useful peripherals limited to those pins and those alone - it was recognized that a single SPI library which could use either of the hardware SPI modules, with any of their pin-swaps. Would provide most of the end user benefits of multiple SPI libraries, while still maintaining compatibility with SPI-using libraries (which is the whole point of a standard SPI library).

As of 1.3.0, the version of SPI.h included with DxCore allows all SPI0 and SPI1 pin mappings to be used via the SPI.swap() and SPI.pins() functions described below. Unlike other peripheral libraries that provide a similar `swap()` method, the SPI library defines constants to pass to `SPI.swap()` - two names for each are shown on the table at the top of this page; the naming of the pin mappings ("DEFAULT", "ALT1", "ALT2") matches what Microchip calls them, and is hence our recommendation. For convenience the numeric values are also listed - though as always, we strongly discourage users from passing numeric values or setting registers to them when named constants are available. Your code is more readable with the constants, and it helps future proof your code.

## SPI pin swap methods
`SPI.swap(SPI0_SWAP_DEFAULT) or SPI.swap(SPI0_SWAP1)` will set the the mapping to the default or alt1 pins. It will return true if this is a valid option for the part you're using, and false if it is not (you don't need to check this, but it may be useful during development). If an invalid option is specified, it will be set to SPI0 on the default pins.

`SPI.pins(MOSIpin, MISOpin, SCKpin);` or `SPI.pins(MOSIpin, MISOpin, SCKpin, SSpin);` can also be used - this will set the mapping to whichever mapping has the specified pins. MISO, MOSI, and SCK must be specified correctly; the SS pin is ignored (the option to specify it is provided only for backwards compatibility. It was decided that requiring it to be passed, when it's functionality would require a different library and is explicitly disabled, didn't really make much sense. If the pins passed are not a valid mapping option, it will return false and set the mapping to the default. This uses more flash than `SPI.swap();` - there is no difference in functionality.

When `SPI.swap()` or `SPI.pins()` is called, assuming it was called with a valid option, the pin mapping requested is saved. When `SPI.begin()` is called, this stored value will specify changes to `PORTMUX.SPIROUTEA` and `PORTx` registers. Thus, if a non-default pin mapping is required, you must set it before before calling `SPI.begin()`. To change the pin mapping after `SPI.begin()` you must turn off SPI with`SPI.end()`, call `SPI.swap()` or `SPI.pins()` and then `SPI.begin()` again.

## SS (Slave Select) pin
On the Dx-series parts, the SS pin can be configured to - when driven low -  switch the SPI peripheral into Slave mode, where it acts as an SPI slave (the same feature was present on the classic AVR parts) - however, this library does not support slave mode (nor - as far as I am aware, has any official SPI library. It would seem that the Arduino userbase is much more enthusiastic about SPI master mode than slave mode; that is not particularly surprising. A basic TWI slave device is much easier to control,
This core disables the SS pin when running in SPI master mode. This means that the "SS" pin can be used for whatever purpose you want - unlike classic AVRs, where the "slave-select" functionality of the SS pin could not be disabled (on classic AVRs, if that pin was input, and it went low - SPI was now in slave mode, whether you like it or not! And within Arduino circles "not" was pretty much universal, since the SPI library there never supported slave mode either).
